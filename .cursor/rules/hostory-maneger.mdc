---
description: 
globs: 
alwaysApply: true
---
# ChatFlow - 統合開発ルール


## 🎉 **開発開始時の掛け声 (毎回必須)**
```
🎉 やるぞ！ChatFlow！
- セキュリティ → 🔒 バッチリ！
- パフォーマンス → ⚡ 最速！  
- コード品質 → ✨ 完璧！
今日も最高のチャットフロー管理システムを作ります！
```

**このメッセージを毎回のチャット開始時・Command+K実行時に表示してから開発作業を開始してください。**

---

Cursor AIがChatFlowプロジェクト開発時に自動的に遵守すべき包括的なルール集

## 🎯 プロジェクト概要

### 目的
- AI開発者のための包括的なチャット履歴管理・分析プラットフォーム
- マルチプラットフォーム統合（Cursor、Claude Dev、ChatGPT、GitHub Copilot）
- SQLite高性能統合によるスケーラブルなデータ処理
- インテリジェント検索とAI支援機能
- WebUIによる直感的なユーザーエクスペリエンス
- エンタープライズセキュリティとコンプライアンス対応

### 主要機能
- 統合チャット管理（マルチプラットフォーム対応）
- インテリジェント検索（AI駆動の意味理解検索）
- 開発分析ダッシュボード（生産性メトリクス可視化）
- AI支援機能（プロンプト最適化・ナレッジベース）
- エンタープライズセキュリティ（暗号化・監査ログ）
- SQLite統合による高速検索（10-100倍高速化）
- 増分同期によるパフォーマンス最適化（90%向上）
- リアルタイム監視とダッシュボード
- VS Code拡張機能との連携

## 🏗️ アーキテクチャ

### プロジェクト構造
```
chatflow/
├── src/                     # CLI + バックエンド
│   ├── cli.ts              # CLIエントリーポイント
│   ├── services/           # ビジネスロジック
│   │   ├── ChatHistoryService.ts    # チャット履歴管理
│   │   ├── AnalyticsService.ts      # 統計・分析機能
│   │   ├── AutoSaveService.ts       # 自動保存機能
│   │   ├── ExportService.ts         # エクスポート機能
│   │   ├── IntegrationService.ts    # 統合管理
│   │   └── SqliteIndexService.ts    # 高速検索エンジン
│   ├── server/             # Express サーバー
│   │   ├── real-api-server.ts       # メインAPIサーバー
│   │   ├── routes/         # API ルート
│   │   └── middleware/     # ミドルウェア
│   ├── types/              # 型定義
│   └── utils/              # ユーティリティ
├── web/                    # React フロントエンド
│   ├── src/
│   │   ├── components/     # UIコンポーネント
│   │   ├── pages/          # ページコンポーネント
│   │   ├── hooks/          # カスタムフック
│   │   └── api/            # API クライアント
│   └── index.html
├── extension/              # VS Code拡張機能
├── scripts/                # 運用・セキュリティスクリプト
├── docs/                   # ドキュメント
└── data/                   # 個人データ（gitignore済み）
```

### 技術スタック
**バックエンド**
- Node.js 18+ / TypeScript 5.3+
- Express.js 5.1+
- SQLite3 + better-sqlite3（高性能DB）
- fs-extra（ファイル操作）

**フロントエンド**
- React 19.1+ / TypeScript
- Vite 6.3+
- TailwindCSS 4.1+
- @tanstack/react-query 5.79+
- React Router 7.6+

**開発ツール**
- ESLint 8.56+ / Prettier 3.5+
- Jest 29.7+ / Concurrently 9.1+

## 💻 基本開発方針

### コード品質
- TypeScript厳格モード: 100%準拠（any型禁止）
- ESLint + Prettier: 統一フォーマット
- 全ての関数・クラスにJSDocコメント必須
- エラーハンドリング: 全非同期処理にtry-catch

### アーキテクチャ原則
- サービス層の責務分離
- 型安全性の徹底
- ミドルウェアパターンによる段階的統合
- フォールバック機能の実装

### 命名規則
- ファイル・ディレクトリ: kebab-case
- クラス・インターフェース・型: PascalCase
- 変数・関数・メソッド: camelCase
- 定数: SCREAMING_SNAKE_CASE
- プライベートメンバー: _prefix

## 🔒 セキュリティ必須事項

### 機密情報保護
- 機密情報のハードコード禁止
- 環境変数でAPI Key管理
- パスワード・token・secretの自動マスキング
- 個人データは`data/`ディレクトリ（gitignore済み）

### 🛡️ コミット前セキュリティチェック (必須実行)
```bash
# コミット前に必ず実行
./scripts/security-check.sh

# 検出対象パターン:
# - OpenAI APIキー (sk-proj-*, sk-*)
# - GitHub Token (ghp_*, gho_*, ghu_*, ghs_*)
# - Stripe キー (pk_*, sk_*)
# - メールアドレス・パスワード・認証情報
# - 環境変数ファイル (.env系)

# 注意: ステージされたファイルに機密情報がある場合、コミットは自動的に中止される
```

### CORS・バリデーション
- すべてのユーザー入力をサニタイズ
- CORS設定の明示的オリジン指定
- ファイルパスサニタイズ

## 🎨 実装パターン

### サービスクラス
```typescript
/**
 * サービスクラスの標準実装パターン
 */
export class XxxService {
  private initialized = false
  
  /**
   * サービス初期化
   */
  async initialize(): Promise<void> {
    try {
      // 初期化処理
      this.initialized = true
    } catch (error) {
      throw new ServiceInitializationError('サービス初期化に失敗しました', { cause: error })
    }
  }
  
  /**
   * メソッド実装例
   */
  async method(): Promise<Result> {
    if (!this.initialized) {
      throw new Error('サービスが初期化されていません')
    }
    
    try {
      // ビジネスロジック
      return result
    } catch (error) {
      logger.error('サービスエラー:', error)
      throw new ServiceError('処理に失敗しました', { cause: error })
    }
  }
}
```

### API エンドポイント
```typescript
/**
 * Express API エンドポイントの標準パターン
 */
router.get('/endpoint', async (req, res) => {
  try {
    // バリデーション
    const validatedData = validateInput(req.body)
    
    // サービス呼び出し
    const result = await service.method(validatedData)
    
    // レスポンス
    res.json({
      success: true,
      data: result,
      timestamp: new Date()
    })
  } catch (error) {
    logger.error('API Error:', error)
    res.status(error.statusCode || 500).json({
      success: false,
      error: error.message,
      timestamp: new Date()
    })
  }
})
```

### React コンポーネント
```typescript
/**
 * React コンポーネントの標準パターン
 */
interface Props {
  readonly session: Session
  readonly onSelect: (id: string) => void
}

export const Component: React.FC<Props> = ({ session, onSelect }) => {
  // React Query利用推奨
  const { data, error, isLoading } = useQuery({
    queryKey: ['sessions', session.id],
    queryFn: () => apiClient.getSession(session.id)
  })
  
  // エラー・ローディング状態の適切な処理
  if (error) return <ErrorComponent error={error} />
  if (isLoading) return <LoadingComponent />
  
  return (
    <div 
      className="card-hover cursor-pointer"
      onClick={() => onSelect(session.id)}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => e.key === 'Enter' && onSelect(session.id)}
    >
      <h3 className="font-semibold text-gray-900">{session.title}</h3>
      <p className="text-sm text-gray-500">{session.metadata.description}</p>
    </div>
  )
}
```

## ⚡ パフォーマンス最適化

### SQLite統合ルール
```typescript
/**
 * SQLite最適化パターン
 */
class SqliteIndexService {
  // バッチ処理: 50-100件ずつ
  private readonly BATCH_SIZE = 100
  
  // プリペアドステートメント使用
  private insertStatement = this.db.prepare(`
    INSERT INTO sessions (id, title, content, timestamp)
    VALUES (?, ?, ?, ?)
  `)
  
  // FTS5全文検索活用
  async searchSessions(keyword: string): Promise<Session[]> {
    return this.db.prepare(`
      SELECT * FROM sessions_fts 
      WHERE content MATCH ? 
      ORDER BY rank LIMIT ?
    `).all(keyword, 100)
  }
}
```

### 増分同期ルール
```typescript
/**
 * 増分同期パターン
 */
class IncrementalIndexService {
  // チェックサムベースの変更検出
  private async detectChanges(files: string[]): Promise<string[]> {
    const changed = []
    for (const file of files) {
      const currentChecksum = await this.calculateChecksum(file)
      const storedChecksum = await this.getStoredChecksum(file)
      
      if (currentChecksum !== storedChecksum) {
        changed.push(file)
      }
    }
    return changed
  }
  
  // キューベースの非同期更新
  private async processQueue(): Promise<void> {
    while (this.updateQueue.length > 0) {
      const batch = this.updateQueue.splice(0, this.BATCH_SIZE)
      await this.processBatch(batch)
    }
  }
}
```

## 📊 品質基準

### パフォーマンス指標
- API応答時間: < 200ms
- SQLite検索: < 100ms（10-100倍高速化）
- 増分同期: < 30秒（90%高速化）
- メモリ使用量: < 500MB
- フロントエンド初期ロード: < 3秒

### エラー処理
```typescript
/**
 * エラーハンドリングパターン
 */
class CustomError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500,
    options?: ErrorOptions
  ) {
    super(message, options)
    this.name = this.constructor.name
  }
}

// 使用例
throw new SessionNotFoundError('セッションが見つかりません', 'SESSION_NOT_FOUND', 404)
```

## 🔄 開発フロー

### 🔍 **探索重視型開発フロー（修正作業時必須）**
**ルール**: `.cursor/rules/exploration-driven-development.mdc`  
**テンプレート**: `docs/templates/`  

修正・バグ・データ問題発見時は**必ず探索フェーズから開始**：
1. **探索レポート作成**: `docs/templates/exploration-report-template.md`を使用
2. **詳細調査実行**: 影響範囲・根本原因・リスク評価
3. **修正戦略決定**: 探索結果に基づく適切なアプローチ選択
4. **ブランチ作成**: 探索完了後のみブランチ作成許可
5. **テスト結果記録**: `docs/templates/test-results-template.md`を使用

### 開発前チェックリスト
- [ ] Issue確認・ブランチ作成(命名規則準拠)
- [ ] **探索レポート作成（修正作業の場合）**
- [ ] 型定義から設計開始
- [ ] セキュリティ要件確認

### 開発中チェックリスト
- [ ] TypeScript型定義完了
- [ ] エラーハンドリング実装  
- [ ] JSDocコメント追加
- [ ] パフォーマンス考慮

### 開発完了チェックリスト
- [ ] `./scripts/security-check.sh` 実行・通過 (機密情報チェック)
- [ ] `npm run quality`通過(lint + format + build)
- [ ] テスト実行・通過
- [ ] **ドキュメント更新（統合原則準拠）**:
  - [ ] 統合API変更時: API_SPEC.md + USAGE.md 更新
  - [ ] 新機能追加時: 該当ドキュメント即座更新
  - [ ] 統合コマンド変更時: USAGE.md + README.md 更新
  - [ ] セキュリティ変更時: SECURITY.md 更新
  - [ ] 関連ドキュメント間の整合性確認

## 🛠️ コマンド・スクリプト

### 開発コマンド
```bash
npm run dev:full     # フルスタック開発環境
npm run server       # APIサーバーのみ
npm run web          # フロントエンドのみ
npm run build        # TypeScriptビルド
npm run web:build    # フロントエンドビルド
npm run quality      # 包括的品質チェック
```

### SQLite管理
```bash
# SQLite統合テスト
curl -X POST http://localhost:3001/api/integration/sqlite-migrate

# 高速検索テスト
curl -X POST -H "Content-Type: application/json" \
  -d '{"keyword":"cursor","options":{"page":1,"pageSize":5}}' \
  http://localhost:3001/api/integration/sqlite-search

# 統計情報確認
curl -s http://localhost:3001/api/integration/enhanced-stats | jq .
```

### セキュリティ
```bash
# 機密情報チェック（コミット前必須）
./scripts/security-check.sh

# Gitクリーンアップ（緊急時）
git reflog expire --expire=now --all && git gc --prune=now --aggressive
```

## 📈 データモデル

### 統合データ型
```typescript
interface IntegratedLog {
  readonly id: string
  readonly timestamp: Date
  readonly type: 'chat' | 'cursor' | 'sqlite'
  readonly content: string
  readonly metadata: {
    project?: string
    tags?: string[]
    source: string
    performance?: PerformanceMetrics
  }
  readonly relatedLogs?: string[]
}

interface PerformanceMetrics {
  readonly processingTime: number
  readonly memoryUsage: number
  readonly searchLatency?: number
}
```

### SQLite スキーマ
```sql
-- セッションテーブル
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  metadata TEXT -- JSON形式
);

-- FTS5全文検索テーブル
CREATE VIRTUAL TABLE sessions_fts USING fts5(
  id, title, content,
  content='sessions',
  content_rowid='rowid'
);
```

## 🚨 禁止事項

- `any` 型の使用
- console.log の本番残留
- 未処理のPromise
- 機密情報のコンソール出力
- インライン スタイル
- ハードコードされた設定値

## 🔍 デバッグ・トラブルシューティング

### 一般的な問題と解決法
```typescript
// 1. SQLite接続エラー
// 解決: データベースファイルの権限確認
await fs.access(dbPath, fs.constants.R_OK | fs.constants.W_OK)

// 2. メモリリーク
// 解決: 適切なリソース解放
finally {
  if (db) db.close()
  if (stream) stream.destroy()
}

// 3. パフォーマンス低下
// 解決: バッチ処理とインデックス最適化
const batchSize = Math.min(records.length, MAX_BATCH_SIZE)
```

### ログ出力パターン
```typescript
// 構造化ログ
logger.info('セッション検索実行', {
  keyword,
  resultCount: results.length,
  executionTime: Date.now() - startTime,
  method: 'sqlite'
})
```

## 📝 ドキュメント要件・更新ルール

### 必須ドキュメント
1. API仕様書（統合APIルート反映）
2. セキュリティガイドライン（統合後対応）
3. パフォーマンス最適化ガイド
4. トラブルシューティングガイド

### コードドキュメント
- すべての公開APIにJSDoc
- 複雑なロジックに日本語コメント
- 実用的な@exampleの提供
- パフォーマンス改善の記録

### 📚 ドキュメント更新ルール（統合原則対応）

#### 🔄 即座更新が必要な場合
```bash
# 以下の変更時は該当ドキュメント即座更新必須
1. 統合APIエンドポイント変更 → API_SPEC.md + USAGE.md
2. 統合コマンド変更 → USAGE.md + README.md
3. セキュリティ仕様変更 → SECURITY.md
4. 統合原則変更 → 全統合関連ドキュメント
```

#### 📂 ドキュメント配置・移動基準
```typescript
// docsフォルダ保持基準
interface DocsRetentionCriteria {
  継続的価値: boolean    // 今後も参照される
  最新性: boolean        // 統合後状況と整合
  実用性: boolean        // 実際の開発・運用で使用
  包括性: boolean        // 統合アーキテクチャ全体をカバー
}

// notesフォルダ移動基準  
interface NotesMoveCriteria {
  バグ修正記録: boolean     // 過去の問題対応記録
  実装ステータス: boolean   // 特定時点の実装状況
  テスト結果: boolean       // 特定時点のテスト結果
  一時的修正: boolean       // 暫定対応・修正記録
}

// archived移動基準
interface ArchivedMoveCriteria {
  古い計画書: boolean       // 統合前の計画・提案書
  旧分析レポート: boolean   // 統合前の分析結果
  重複ガイド: boolean       // 同内容の新ドキュメント存在
  時期限定: boolean         // 特定時期のみ有効
}
```

#### 🔍 ドキュメント品質チェック
```bash
# 月次レビュー時の必須チェック項目
docs_quality_check() {
  # 1. 統合原則整合性
  grep -r "chat-history-manager search" docs/ && echo "❌ 旧CLI残存"
  grep -r "localhost:3000" docs/ && echo "❌ 旧ポート残存"
  
  # 2. リンク整合性  
  find docs/ -name "*.md" -exec grep -l "](.*\.md)" {} \; | while read f; do
    echo "リンクチェック: $f"
  done
  
  # 3. 最新性確認
  find docs/ -name "*.md" -exec grep -l "2024" {} \; && echo "⚠️ 古い日付発見"
  
  # 4. 統合API整合性
  grep -r "/api/chat" docs/ && echo "❌ 旧API残存"
}
```

#### 📋 定期メンテナンスフロー
```bash
# 月次ドキュメント整備（npm run monthly:review に組み込み）
monthly_docs_review() {
  echo "📚 ドキュメント整合性確認中..."
  
  # 1. 古い情報検出
  docs_quality_check
  
  # 2. 統合状況反映確認
  curl -s http://localhost:3001/api/health | jq '.services' > /tmp/current_services.json
  echo "現在のサービス構成とドキュメント記載の整合性確認推奨"
  
  # 3. パフォーマンス指標更新
  echo "📊 最新パフォーマンス指標をドキュメントに反映してください"
}
```

#### 🎯 ドキュメント作成時のチェックリスト
```markdown
## 新規ドキュメント作成時の必須確認
- [ ] 統合原則準拠（source分岐・unified-api使用等）
- [ ] 最新コマンド体系使用（npm run scripts）
- [ ] 統合後のファイル構造反映
- [ ] 実際のテスト実行による動作確認
- [ ] セキュリティ観点の考慮
- [ ] パフォーマンス影響の記載
- [ ] 関連ドキュメントとの整合性確認
```

#### 🔗 ドキュメント間連携ルール
```typescript
// 相互参照必須パターン
const DOC_REFERENCES = {
  'API_SPEC.md': ['USAGE.md', 'SECURITY.md'],
  'USAGE.md': ['API_SPEC.md', 'INTEGRATION_*.md'],
  'SECURITY.md': ['API_SPEC.md', 'USAGE.md'],
  '新機能ドキュメント': ['既存統合ドキュメント群']
}

// 更新時の連鎖更新チェック
const update_related_docs = (changedDoc: string) => {
  const relatedDocs = DOC_REFERENCES[changedDoc] || []
  console.log(`${changedDoc} 更新時、以下の確認推奨:`, relatedDocs)
}
```

## 🔗 **Claude DEV統合専用ルール (冗長化予防)**

### 統合設計の強制原則
- **データベース一元化**: 全サービスで`data/chat-history.db`使用必須
- **サービス階層遵守**: 独立サービス作成禁止、アダプターパターン必須
- **API統一**: `/api/sessions?source=X`形式、専用エンドポイント作成禁止
- **設定統合**: 分散設定ファイル禁止、統一設定構造必須

### 新機能開発時の必須チェック
```bash
# 開発前に必ず確認
1. 既存サービスで実現可能か？ (99%は拡張で対応)
2. データベーススキーマ拡張で対応可能か？
3. 新APIエンドポイントが本当に必要か？ (フィルターで対応推奨)
4. 設定ファイルの重複は発生しないか？
```

### 禁止パターン (即座にエラー)
```typescript
// ❌ 絶対禁止
const claudeDevDb = 'data/claude-dev.db'        // 分散DB
export class ClaudeDevService extends Service   // 独立サービス
GET /api/claude-dev/sessions                    // 専用API
const claudeDevConfig = { ... }                 // 個別設定
```

### 自動チェック実装
- **ESLintルール**: 重複API・DB分散の自動検出
- **プリコミットフック**: ファイル重複・命名規則チェック
- **CI/CD**: 統合違反の自動検出とビルド停止

---

## 🔍 **根本原因分析・段階的統合ルール (2024年12月追加)**

**適用背景**: Phase 3開発時36件TypeScriptエラー発生の根本原因分析により策定  
**目的**: 破壊的変更回避、システム安定性確保、開発リスク最小化

### 🏗️ **段階的統合の強制原則**

#### **絶対禁止: Big Bang展開**
```typescript
// ❌ 破壊的変更パターン (絶対禁止)
class ExistingService {
  // 既存メソッドを削除して新機能で置き換え
  // async existingMethod() { /* 削除 */ }
  async newMethod() { /* 新実装 */ }  // ← システム破壊
}

// ✅ 安全な段階的統合パターン (必須)
class ExistingService {
  // === 既存メソッド完全保持 ===
  async existingMethod() { /* 既存実装維持 */ }
  
  // === 新機能段階的追加 ===
  async enhancedMethod() { /* 新機能追加 */ }
  async experimentalMethod() { /* 実験機能 */ }
}
```

#### **段階的統合チェックリスト (必須)**
```bash
# 新機能開発前の必須確認
stage_integration_check() {
  echo "🔍 段階的統合チェック開始"
  
  # 1. 既存インターフェース保護確認
  echo "❓ 既存のpublicメソッドを削除・変更しますか？"
  echo "❓ 既存APIエンドポイントを変更しますか？"
  echo "❓ 既存データベーススキーマを変更しますか？"
  
  # 2. 段階的追加確認
  echo "❓ 新機能は既存機能と独立して動作しますか？"
  echo "❓ 問題発生時に新機能だけを無効化できますか？"
  echo "❓ 既存ユーザーへの影響はゼロですか？"
  
  # 3. フォールバック戦略確認
  echo "❓ 新機能失敗時の既存機能への切り戻し手順は確立されていますか？"
}
```

### 📦 **ESモジュール規約の厳格遵守**

#### **インポートパス規約 (絶対遵守)**
```typescript
// ❌ Node.js 16+ で必ずエラーになるパターン
import { Service } from '../services/Service'
import { Utils } from './utils/index'
import type { Types } from '../types/Types'

// ✅ 正しいESモジュール形式 (必須)
import { Service } from '../services/Service.js'
import { Utils } from './utils/index.js'
import type { Types } from '../types/Types.js'
```

#### **自動チェック・修正スクリプト**
```bash
# 開発時の必須確認
esmodule_compliance_check() {
  # インポートパス一括チェック
  grep -r "from.*\.\." src/ --include="*.ts" | grep -v "\.js'" && {
    echo "❌ ESモジュール規約違反発見"
    echo "📖 修正方法: find src/ -name '*.ts' -exec sed -i 's/from '\''\.\.\//from '\''&.js/g' {} \;"
    return 1
  }
  
  echo "✅ ESモジュール規約準拠"
}
```

### 🌐 **TypeScript型安全性の原則**

#### **型定義の明示化 (必須)**
```typescript
// ❌ 暗黙的any型 (strict設定でエラー)
router.get('/api', async (req, res) => {
  try {
    // TypeScript: req, resの型が不明
  } catch (error) {
    error.message  // unknown型エラー
  }
})

// ✅ 明示的型指定 (必須)
router.get('/api', async (req: Request, res: Response) => {
  try {
    // 型安全な実装
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : '不明なエラー'
    logger.error('API Error:', errorMessage)
  }
})
```

#### **エラーハンドリング標準パターン**
```typescript
// 必須: unknown型エラーの安全な処理
function safeErrorHandler(error: unknown): string {
  if (error instanceof Error) {
    return error.message
  }
  if (typeof error === 'string') {
    return error
  }
  return '不明なエラーが発生しました'
}

// 使用例
try {
  await riskyOperation()
} catch (error: unknown) {
  const errorMessage = safeErrorHandler(error)
  logger.error('Operation failed:', errorMessage)
  res.status(500).json({ 
    success: false, 
    error: errorMessage 
  })
}
```

### 🚨 **破壊的変更の事前検出**

#### **影響範囲分析 (必須実行)**
```bash
# 変更前の必須実行
breaking_change_analysis() {
  local target_file="$1"
  
  echo "🔍 破壊的変更分析: $target_file"
  
  # 1. 依存関係調査
  echo "📊 依存ファイル検索中..."
  grep -r "$(basename $target_file .ts)" src/ --include="*.ts" | head -10
  
  # 2. 公開API調査
  echo "📋 公開メソッド検索中..."
  grep -E "export|public" "$target_file"
  
  # 3. 既存テスト影響調査
  echo "🧪 テスト依存性確認中..."
  find . -name "*.test.ts" -exec grep -l "$(basename $target_file .ts)" {} \;
  
  echo "⚠️ 上記の依存関係を確認してから変更を実行してください"
}
```

#### **段階的ビルド確認 (必須)**
```bash
# 開発中の継続的確認
continuous_build_check() {
  echo "🔨 段階的ビルド確認開始"
  
  # ステップ1: TypeScript型チェック
  npx tsc --noEmit && echo "✅ 型チェック通過" || {
    echo "❌ 型エラーを修正してください"
    return 1
  }
  
  # ステップ2: ESLint
  npm run lint && echo "✅ Lint通過" || {
    echo "❌ Lintエラーを修正してください"
    return 1
  }
  
  # ステップ3: ビルド
  npm run build && echo "✅ ビルド通過" || {
    echo "❌ ビルドエラーを修正してください"
    return 1
  }
  
  echo "🎉 段階的ビルド確認完了"
}
```

### 🔄 **分離並行開発パターン**

#### **新機能分離実装 (推奨)**
```typescript
// ✅ 推奨: 分離並行開発パターン
// 既存サービス (完全保持)
export class ChatHistoryService {
  // 既存機能はそのまま維持
  async getSessions() { /* 既存実装 */ }
  async getStats() { /* 既存実装 */ }
}

// 新機能サービス (完全独立)
export class EnhancedSearchService {
  // 新機能を独立実装
  async fastSearch() { /* 新実装 */ }
  async advancedMetrics() { /* 新実装 */ }
}

// API層での統合
app.use('/api/sessions', existingRoutes)     // 既存API
app.use('/api/search/v2', newRoutes)         // 新API
```

#### **データベース分離パターン**
```typescript
// ✅ リスク分散: データベース分離
interface DatabaseSeparation {
  existing: 'data/chat-history.db'      // 既存データ保護
  experimental: 'data/experimental.db'  // 新機能実験
  performance: 'data/performance.db'    // 性能測定用
}

// 段階的データ移行
async function safeMigration() {
  // 1. 実験DBで新機能テスト
  await testNewFeatures('data/experimental.db')
  
  // 2. 性能比較
  const oldPerf = await measurePerformance('data/chat-history.db')
  const newPerf = await measurePerformance('data/experimental.db')
  
  // 3. 改善確認後に本格移行判断
  if (newPerf.speed > oldPerf.speed * 1.5) {
    await considerMigration()
  }
}
```

### 📊 **根本原因分析の活用**

#### **問題発生時の分析手順 (必須)**
```bash
# 問題発生時の標準分析フロー
root_cause_analysis() {
  local issue="$1"
  
  echo "🔍 根本原因分析開始: $issue"
  
  # Phase 1: 現象整理
  echo "📋 現象・症状の詳細記録"
  echo "❓ いつから発生？"
  echo "❓ どの操作で発生？"
  echo "❓ エラーメッセージは？"
  
  # Phase 2: 直接原因特定
  echo "🎯 直接原因の特定"
  echo "❓ 最近の変更は？"
  echo "❓ 関連ファイルの修正は？"
  echo "❓ 依存関係の変更は？"
  
  # Phase 3: 根本原因深堀り
  echo "🏗️ 根本原因の深堀り"
  echo "❓ なぜその変更をしたか？"
  echo "❓ 設計・プロセスの問題は？"
  echo "❓ 予防可能だったか？"
  
  # Phase 4: 予防策策定
  echo "🛡️ 再発防止策の策定"
  echo "📋 ルール・チェックリストの追加"
  echo "🔧 自動検出ツールの導入"
  echo "📚 ドキュメント・教育の改善"
}
```

### 🎯 **自動適用タイミング**

この根本原因分析・段階的統合ルールは以下の場面で**自動適用**：

- **既存サービス修正時**: 破壊的変更チェック
- **新機能開発時**: 段階的統合原則の確認  
- **ファイル名変更時**: インポートパス影響調査
- **API追加時**: 既存API互換性確認
- **データベース変更時**: 分離・並行開発検討

---

## 📚 関連専用ルール

### 🎨 UI/UX設計作業
- **専用ルール**: `.cursor/rules/ui-ux-design.mdc`
- **自動適用**: フロントエンド開発・UI/UX設計・ドキュメント作成時
- **手動参照**: デザイン・用語検討・品質確認時
- **ドキュメント**: `docs/ui-ux-design/` 体系的参照

### 🔄 プルリクエスト・レビュー作業
- **専用ルール**: `.cursor/rules/pull-request-review.mdc`
- **自動適用**: プルリクエスト作成・レビュー・マージ・マージ後作業時
- **手動参照**: Git操作・セキュリティインシデント・緊急対応時

---

## 🛠️ **CommonJSベース実装ルール (2024年12月追加)**

**適用背景**: サーバー管理統一化で「TypeScript + ES Module複雑性」回避実績  
**目的**: 複雑な設定依存を避け、確実な動作を優先

### 🎯 **CommonJS適用判断基準**

#### **✅ CommonJS推奨シナリオ**
```typescript
interface CommonJSRecommendedScenarios {
  管理系スクリプト: "server-manager.cjs" // サーバー管理・監視
  設定管理: "config-manager.cjs"         // 設定ファイル操作
  運用ツール: "backup-manager.cjs"       // バックアップ・復旧
  緊急対応: "emergency-fix.cjs"          // 障害時の緊急スクリプト
  
  判断基準: {
    即座実行優先: boolean    // 設定不要で即座動作必要
    依存最小化: boolean      // ライブラリ依存を最小に抑制
    デバッグ容易: boolean    // トラブル時の迅速対応必要
    安定性重視: boolean      // 実験的機能より確実動作
  }
}
```

#### **⚖️ TypeScript vs CommonJS 判断フロー**
```bash
# 新スクリプト作成時の必須判断
choose_implementation_type() {
  echo "🤔 実装方式選択ガイド"
  
  echo "❓ このスクリプトは緊急時・運用時に使用しますか？"
  echo "❓ 設定ファイルやビルド設定に依存したくないですか？"
  echo "❓ Node.js標準機能のみで動作させたいですか？"
  
  echo "✅ 3つ以上該当 → CommonJS (.cjs) 推奨"
  echo "🔧 アプリ機能・型安全重要 → TypeScript (.ts) 推奨"
}
```

### 🏗️ **CommonJS実装パターン**

#### **必須構造**
```javascript
#!/usr/bin/env node

/**
 * ChatFlow [機能名] CommonJS実装
 * - 既存システム完全保護
 * - 設定依存最小化
 * - エラーハンドリング充実
 */

const fs = require('fs-extra')
const path = require('path')

const PROJECT_ROOT = path.resolve(__dirname, '..')

class [ClassName] {
  constructor() {
    this.initialize()
  }
  
  initialize() {
    // 初期化処理
  }
  
  // メイン機能
}

// CLI実行部分
async function main() {
  const command = process.argv[2]
  
  try {
    switch (command) {
      case 'start':
        // 処理
        break
      default:
        console.log('使用方法: node script.cjs [command]')
    }
  } catch (error) {
    console.error('❌ エラー:', error.message)
    process.exit(1)
  }
}

if (require.main === module) {
  main()
}

module.exports = { [ClassName] }
```

#### **エラーハンドリング標準**
```javascript
// 必須: 包括的エラーハンドリング
function safeExecution(fn, context = '') {
  try {
    return fn()
  } catch (error) {
    console.error(`❌ ${context}エラー:`, error.message)
    if (error.stack) {
      console.error('📋 スタックトレース:', error.stack)
    }
    return null
  }
}

// 使用例
const result = safeExecution(() => {
  return fs.readJsonSync(configPath)
}, '設定ファイル読み込み')
```

### 📦 **package.json統合パターン**

#### **CommonJSスクリプト登録**
```json
{
  "scripts": {
    "server:manage": "node scripts/unified-server-manager.cjs",
    "backup:create": "node scripts/backup-manager.cjs create",
    "config:check": "node scripts/config-validator.cjs",
    "emergency:fix": "node scripts/emergency-recovery.cjs"
  }
}
```

### 🔍 **デバッグ・トラブルシューティング**

#### **CommonJS特有の問題対応**
```bash
# CommonJSファイルの実行権限確認
chmod +x scripts/*.cjs

# Node.js直接実行テスト
node scripts/target-script.cjs --test

# 依存関係確認
node -e "console.log(require('fs-extra'))"
```

#### **ES Module混在時の対応**
```javascript
// CommonJSからES Moduleの呼び出し
async function callESModule() {
  const { ESModuleFunction } = await import('../dist/es-module.js')
  return ESModuleFunction()
}
```

### 🎯 **成功事例：統一サーバー管理**

#### **実装成果**
- **技術負債回避**: TypeScript + ESM 複雑性を回避
- **運用効率向上**: 6倍高速起動・7倍高速トラブル解決
- **安定性確保**: 設定ファイル依存なしで確実動作
- **保守性向上**: 単純明快なコード構造

#### **適用実績**
```bash
✅ scripts/unified-server-manager.cjs    # サーバー統一管理
✅ jest.config.cjs                       # テスト設定
✅ simple-api-server.cjs                 # 開発用API
```

### 🚨 **注意事項・制限**

#### **CommonJS使用時の制限**
- **型チェックなし**: TypeScriptコンパイラの恩恵なし
- **最新ES機能制限**: Node.js標準サポート範囲内
- **IDE支援限定**: TypeScript比較でIntelliSense制限

#### **緩和策**
- **JSDocコメント**: 型情報をコメントで補完
- **ESLint設定**: コード品質をLintで確保
- **テスト充実**: 型チェック代替として包括的テスト

---

**最終更新**: 2024/12/03（CommonJSベース実装ルール追加）  
**適用範囲**: Chat Flow全体  
**次回見直し**: 機能追加時または月次レビュー
