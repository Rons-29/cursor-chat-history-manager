# ChatFlowÁµ±‰∏ÄÊ§úÁ¥¢Ê©üËÉΩ - „ÉÜ„Çπ„Éà‰ªïÊßòÊõ∏

## üìã ÁõÆÊ¨°
1. [„ÉÜ„Çπ„ÉàÊ¶ÇË¶Å](#„ÉÜ„Çπ„ÉàÊ¶ÇË¶Å)
2. [„É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„Éà](#„É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„Éà)
3. [Áµ±Âêà„ÉÜ„Çπ„Éà](#Áµ±Âêà„ÉÜ„Çπ„Éà)
4. [E2E„ÉÜ„Çπ„Éà](#e2e„ÉÜ„Çπ„Éà)
5. [„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà](#„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà)
6. [„ÉÜ„Çπ„ÉàÂÆüË°å„ÉªÁõ£Ë¶ñ](#„ÉÜ„Çπ„ÉàÂÆüË°åÁõ£Ë¶ñ)

---

## üéØ „ÉÜ„Çπ„ÉàÊ¶ÇË¶Å

### „ÉÜ„Çπ„ÉàÊñπÈáù
- **ÂìÅË≥™‰øùË®º**: Áµ±‰∏ÄÊ§úÁ¥¢Ê©üËÉΩ„ÅÆ‰ø°È†ºÊÄß„Å®ÂÆâÂÆöÊÄßÁ¢∫‰øù
- **„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ**: Ê§úÁ¥¢ÈÄüÂ∫¶„Éª„É¨„Çπ„Éù„É≥„ÇπÊÄßËÉΩ„ÅÆ‰øùË®º
- **„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£**: Áõ¥ÊÑüÁöÑ„Åß‰Ωø„ÅÑ„ÇÑ„Åô„ÅÑÊ§úÁ¥¢‰ΩìÈ®ì„ÅÆÊ§úË®º
- **ÂõûÂ∏∞Èò≤Ê≠¢**: Êó¢Â≠òÊ©üËÉΩ„Å∏„ÅÆÂΩ±ÈüøÊéíÈô§

### „ÉÜ„Çπ„ÉàÁí∞Â¢É
```typescript
interface TestEnvironment {
  development: "„É≠„Éº„Ç´„É´ÈñãÁô∫Áí∞Â¢É„Åß„ÅÆ„É¶„Éã„ÉÉ„Éà„ÉªÁµ±Âêà„ÉÜ„Çπ„Éà"
  staging: "„Çπ„ÉÜ„Éº„Ç∏„É≥„Ç∞Áí∞Â¢É„Åß„ÅÆE2E„Éª„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà"
  production: "Êú¨Áï™Áí∞Â¢É„Åß„ÅÆÁõ£Ë¶ñ„ÉªÂõûÂ∏∞„ÉÜ„Çπ„Éà"
}
```

### „Ç´„Éê„É¨„ÉÉ„Ç∏ÁõÆÊ®ô
```typescript
interface CoverageTargets {
  unitTests: "„Ç≥„Éº„Éâ„Ç´„Éê„É¨„ÉÉ„Ç∏85%‰ª•‰∏ä"
  integrationTests: "API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà100%"
  e2eTests: "‰∏ªË¶Å„É¶„Éº„Ç∂„Éº„Éï„É≠„Éº100%"
  performanceTests: "SLAÈÅµÂÆà100%"
}
```

---

## üß™ „É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„Éà

### UnifiedSearchService „ÉÜ„Çπ„Éà

#### Âü∫Êú¨Ê§úÁ¥¢Ê©üËÉΩ„ÉÜ„Çπ„Éà
```typescript
// src/services/UnifiedSearchService.test.ts
describe('UnifiedSearchService', () => {
  let service: UnifiedSearchService
  let mockSqliteService: jest.Mocked<SqliteIndexService>
  let mockChatService: jest.Mocked<ChatHistoryService>

  beforeEach(() => {
    mockSqliteService = createMockSqliteService()
    mockChatService = createMockChatService()
    service = new UnifiedSearchService(mockSqliteService, mockChatService)
  })

  describe('searchAll', () => {
    it('should search sessions, messages, and tags simultaneously', async () => {
      // Arrange
      const query = 'React TypeScript'
      const filters = {
        includeSessionTitles: true,
        includeMessageContent: true,
        includeTags: true
      }
      
      mockSqliteService.searchSessions.mockResolvedValue([
        { id: 'session1', title: 'React Development', score: 0.9 }
      ])
      mockSqliteService.searchMessages.mockResolvedValue([
        { sessionId: 'session1', content: 'TypeScript error', score: 0.8 }
      ])
      mockSqliteService.searchTags.mockResolvedValue([
        { tag: 'React', sessionCount: 5 }
      ])

      // Act
      const result = await service.searchAll(query, filters)

      // Assert
      expect(result.query).toBe(query)
      expect(result.total.sessions).toBe(1)
      expect(result.total.messages).toBe(1)
      expect(result.total.tags).toBe(1)
      expect(result.performance.searchTime).toBeGreaterThan(0)
    })

    it('should handle empty query gracefully', async () => {
      // Act
      const result = await service.searchAll('', {})

      // Assert
      expect(result.total.sessions).toBe(0)
      expect(result.total.messages).toBe(0)
      expect(result.total.tags).toBe(0)
    })

    it('should handle service errors gracefully', async () => {
      // Arrange
      mockSqliteService.searchSessions.mockRejectedValue(new Error('DB Error'))

      // Act & Assert
      await expect(service.searchAll('test', {})).rejects.toThrow('DB Error')
    })
  })

  describe('calculateRelevanceScore', () => {
    it('should calculate higher scores for exact matches', () => {
      // Arrange
      const item = { title: 'React Tutorial', content: 'Learn React from scratch' }
      const query = 'React'

      // Act
      const score = service.calculateRelevanceScore(item, query)

      // Assert
      expect(score).toBeGreaterThan(0)
      expect(score).toBeLessThanOrEqual(1)
    })

    it('should calculate lower scores for partial matches', () => {
      // Arrange
      const item = { title: 'Web Development', content: 'Various topics' }
      const query = 'React'

      // Act
      const score = service.calculateRelevanceScore(item, query)

      // Assert
      expect(score).toBe(0)
    })
  })

  describe('highlightText', () => {
    it('should highlight single keyword', () => {
      // Arrange
      const text = 'React is a JavaScript library'
      const query = 'React'

      // Act
      const highlighted = service.highlightText(text, query)

      // Assert
      expect(highlighted).toBe('<mark>React</mark> is a JavaScript library')
    })

    it('should highlight multiple keywords', () => {
      // Arrange
      const text = 'React is a JavaScript library'
      const query = 'React JavaScript'

      // Act
      const highlighted = service.highlightText(text, query)

      // Assert
      expect(highlighted).toContain('<mark>React</mark>')
      expect(highlighted).toContain('<mark>JavaScript</mark>')
    })

    it('should be case insensitive', () => {
      // Arrange
      const text = 'React is a JavaScript library'
      const query = 'react javascript'

      // Act
      const highlighted = service.highlightText(text, query)

      // Assert
      expect(highlighted).toContain('<mark>React</mark>')
      expect(highlighted).toContain('<mark>JavaScript</mark>')
    })
  })
})
```

### React „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÉÜ„Çπ„Éà

#### UnifiedSearch „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÉÜ„Çπ„Éà
```typescript
// web/src/components/search/UnifiedSearch.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { UnifiedSearch } from './UnifiedSearch'

// „ÉÜ„Çπ„Éà„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
const createTestQueryClient = () => new QueryClient({
  defaultOptions: { queries: { retry: false } }
})

const renderWithQueryClient = (component: React.ReactElement) => {
  const queryClient = createTestQueryClient()
  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  )
}

describe('UnifiedSearch', () => {
  beforeEach(() => {
    // API„É¢„ÉÉ„ÇØË®≠ÂÆö
    jest.spyOn(require('../api/client'), 'apiClient').mockReturnValue({
      searchUnified: jest.fn().mockResolvedValue({
        query: 'test',
        total: { sessions: 1, messages: 2, tags: 1 },
        results: { sessions: [], messages: [], tags: [] }
      })
    })
  })

  it('should render search input and placeholder', () => {
    // Act
    renderWithQueryClient(<UnifiedSearch />)

    // Assert
    expect(screen.getByPlaceholderText(/„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥ÂÖ®‰Ωì„ÇíÊ§úÁ¥¢/)).toBeInTheDocument()
  })

  it('should trigger search on input change', async () => {
    // Arrange
    const mockSearch = jest.fn()
    jest.spyOn(require('../hooks/useUnifiedSearch'), 'useUnifiedSearch')
      .mockReturnValue({ data: null, isLoading: false, error: null })

    // Act
    renderWithQueryClient(<UnifiedSearch />)
    const input = screen.getByPlaceholderText(/„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥ÂÖ®‰Ωì„ÇíÊ§úÁ¥¢/)
    fireEvent.change(input, { target: { value: 'React' } })

    // Assert
    expect(input).toHaveValue('React')
  })

  it('should display search results', async () => {
    // Arrange
    const mockResults = {
      query: 'React',
      total: { sessions: 1, messages: 1, tags: 0 },
      results: {
        sessions: [{
          id: 'session1',
          title: 'React Tutorial',
          matchInfo: { score: 0.9, highlightedTitle: '<mark>React</mark> Tutorial' }
        }],
        messages: [{
          sessionId: 'session1',
          content: 'Learn React',
          matchInfo: { score: 0.8, highlightedContent: 'Learn <mark>React</mark>' }
        }],
        tags: []
      }
    }

    jest.spyOn(require('../hooks/useUnifiedSearch'), 'useUnifiedSearch')
      .mockReturnValue({ data: mockResults, isLoading: false, error: null })

    // Act
    renderWithQueryClient(<UnifiedSearch />)

    // Assert
    await waitFor(() => {
      expect(screen.getByText(/React Tutorial/)).toBeInTheDocument()
      expect(screen.getByText(/Learn React/)).toBeInTheDocument()
    })
  })

  it('should handle loading state', () => {
    // Arrange
    jest.spyOn(require('../hooks/useUnifiedSearch'), 'useUnifiedSearch')
      .mockReturnValue({ data: null, isLoading: true, error: null })

    // Act
    renderWithQueryClient(<UnifiedSearch />)

    // Assert
    expect(screen.getByText(/Ê§úÁ¥¢‰∏≠/)).toBeInTheDocument()
  })

  it('should handle error state', () => {
    // Arrange
    const error = new Error('Search failed')
    jest.spyOn(require('../hooks/useUnifiedSearch'), 'useUnifiedSearch')
      .mockReturnValue({ data: null, isLoading: false, error })

    // Act
    renderWithQueryClient(<UnifiedSearch />)

    // Assert
    expect(screen.getByText(/Ê§úÁ¥¢„Ç®„É©„Éº/)).toBeInTheDocument()
  })
})
```

#### SearchFilters „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÉÜ„Çπ„Éà
```typescript
// web/src/components/search/SearchFilters.test.tsx
describe('SearchFilters', () => {
  const defaultFilters = {
    sessions: true,
    messages: true,
    tags: true,
    dateRange: null,
    sources: []
  }

  it('should render all filter options', () => {
    // Act
    render(<SearchFilters filters={defaultFilters} onFiltersChange={jest.fn()} />)

    // Assert
    expect(screen.getByText(/„Çª„ÉÉ„Ç∑„Éß„É≥/)).toBeInTheDocument()
    expect(screen.getByText(/„É°„ÉÉ„Çª„Éº„Ç∏/)).toBeInTheDocument()
    expect(screen.getByText(/„Çø„Ç∞/)).toBeInTheDocument()
  })

  it('should toggle session filter', () => {
    // Arrange
    const mockOnChange = jest.fn()

    // Act
    render(<SearchFilters filters={defaultFilters} onFiltersChange={mockOnChange} />)
    fireEvent.click(screen.getByText(/„Çª„ÉÉ„Ç∑„Éß„É≥/))

    // Assert
    expect(mockOnChange).toHaveBeenCalledWith({
      ...defaultFilters,
      sessions: false
    })
  })

  it('should handle date range selection', () => {
    // Arrange
    const mockOnChange = jest.fn()

    // Act
    render(<SearchFilters filters={defaultFilters} onFiltersChange={mockOnChange} />)
    // Êó•‰ªòÈÅ∏Êäû„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÔºàÂÆüË£ÖË©≥Á¥∞„Å´„Çà„ÇãÔºâ

    // Assert
    // Êó•‰ªòÁØÑÂõ≤„ÅåÊ≠£„Åó„ÅèË®≠ÂÆö„Åï„Çå„Çã„Åì„Å®„ÇíÊ§úË®º
  })
})
```

---

## üîó Áµ±Âêà„ÉÜ„Çπ„Éà

### APIÁµ±Âêà„ÉÜ„Çπ„Éà

#### Áµ±‰∏ÄÊ§úÁ¥¢API„ÉÜ„Çπ„Éà
```typescript
// src/server/routes/search.integration.test.ts
import request from 'supertest'
import { app } from '../app'
import { testDatabase } from '../test-utils/database'

describe('Unified Search API Integration', () => {
  beforeAll(async () => {
    await testDatabase.setup()
    await testDatabase.seedTestData()
  })

  afterAll(async () => {
    await testDatabase.cleanup()
  })

  describe('POST /api/search/unified', () => {
    it('should return search results for valid query', async () => {
      // Act
      const response = await request(app)
        .post('/api/search/unified')
        .send({
          query: 'React TypeScript',
          filters: {
            includeSessionTitles: true,
            includeMessageContent: true,
            includeTags: true
          }
        })
        .expect(200)

      // Assert
      expect(response.body.success).toBe(true)
      expect(response.body.data.query).toBe('React TypeScript')
      expect(response.body.data.total).toEqual(
        expect.objectContaining({
          sessions: expect.any(Number),
          messages: expect.any(Number),
          tags: expect.any(Number)
        })
      )
      expect(response.body.data.results).toEqual(
        expect.objectContaining({
          sessions: expect.any(Array),
          messages: expect.any(Array),
          tags: expect.any(Array)
        })
      )
      expect(response.body.data.performance.searchTime).toBeGreaterThan(0)
    })

    it('should validate query parameter', async () => {
      // Act
      const response = await request(app)
        .post('/api/search/unified')
        .send({ query: '' })
        .expect(400)

      // Assert
      expect(response.body.success).toBe(false)
      expect(response.body.error).toContain('„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„ÅåÂøÖË¶Å')
    })

    it('should handle invalid filters gracefully', async () => {
      // Act
      const response = await request(app)
        .post('/api/search/unified')
        .send({
          query: 'test',
          filters: { invalidFilter: true }
        })
        .expect(200)

      // Assert
      expect(response.body.success).toBe(true)
      // ÁÑ°Âäπ„Å™„Éï„Ç£„É´„Çø„Éº„ÅØÁÑ°Ë¶ñ„Åï„Çå„ÄÅÊ§úÁ¥¢„ÅØÊ≠£Â∏∏ÂÆüË°å„Åï„Çå„Çã
    })

    it('should respect filter settings', async () => {
      // Act - „Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆ„ÅøÊ§úÁ¥¢
      const response = await request(app)
        .post('/api/search/unified')
        .send({
          query: 'React',
          filters: {
            includeSessionTitles: true,
            includeMessageContent: false,
            includeTags: false
          }
        })
        .expect(200)

      // Assert
      expect(response.body.data.results.sessions).toBeDefined()
      expect(response.body.data.total.messages).toBe(0)
      expect(response.body.data.total.tags).toBe(0)
    })
  })

  describe('GET /api/search/suggestions', () => {
    it('should return search suggestions', async () => {
      // Act
      const response = await request(app)
        .get('/api/search/suggestions?q=Rea')
        .expect(200)

      // Assert
      expect(response.body.success).toBe(true)
      expect(response.body.data).toEqual(
        expect.objectContaining({
          recent: expect.any(Array),
          popular: expect.any(Array)
        })
      )
    })

    it('should handle empty query', async () => {
      // Act
      const response = await request(app)
        .get('/api/search/suggestions')
        .expect(200)

      // Assert
      expect(response.body.success).toBe(true)
      expect(response.body.data.recent).toEqual([])
      expect(response.body.data.popular).toEqual([])
    })
  })
})
```

### „Éá„Éº„Çø„Éô„Éº„ÇπÁµ±Âêà„ÉÜ„Çπ„Éà

#### SQLiteÊ§úÁ¥¢Ê©üËÉΩ„ÉÜ„Çπ„Éà
```typescript
// src/services/SqliteIndexService.integration.test.ts
describe('SqliteIndexService Integration', () => {
  let service: SqliteIndexService
  let testDb: Database

  beforeAll(async () => {
    testDb = await setupTestDatabase()
    service = new SqliteIndexService(testDb)
    await seedTestData(testDb)
  })

  afterAll(async () => {
    await testDb.close()
  })

  describe('searchSessions', () => {
    it('should find sessions by title', async () => {
      // Act
      const results = await service.searchSessions('React Tutorial')

      // Assert
      expect(results).toHaveLength(1)
      expect(results[0].title).toContain('React Tutorial')
    })

    it('should find sessions by content', async () => {
      // Act
      const results = await service.searchSessions('TypeScript error')

      // Assert
      expect(results.length).toBeGreaterThan(0)
      results.forEach(result => {
        expect(result.preview || result.title).toMatch(/TypeScript|error/i)
      })
    })

    it('should respect date range filter', async () => {
      // Arrange
      const dateRange = {
        start: new Date('2024-01-01'),
        end: new Date('2024-12-31')
      }

      // Act
      const results = await service.searchSessions('React', { dateRange })

      // Assert
      results.forEach(result => {
        const createdAt = new Date(result.createdAt)
        expect(createdAt).toBeGreaterThanOrEqual(dateRange.start)
        expect(createdAt).toBeLessThanOrEqual(dateRange.end)
      })
    })
  })

  describe('searchMessages', () => {
    it('should find messages by content', async () => {
      // Act
      const results = await service.searchMessages('error handling')

      // Assert
      expect(results.length).toBeGreaterThan(0)
      results.forEach(result => {
        expect(result.content.toLowerCase()).toMatch(/error|handling/)
      })
    })

    it('should return message context', async () => {
      // Act
      const results = await service.searchMessages('React', { includeContext: true })

      // Assert
      results.forEach(result => {
        expect(result.context).toBeDefined()
        expect(result.context.before).toBeDefined()
        expect(result.context.after).toBeDefined()
      })
    })
  })
})
```

---

## üñ•Ô∏è E2E„ÉÜ„Çπ„Éà

### „É¶„Éº„Ç∂„Éº„Éï„É≠„Éº„ÉÜ„Çπ„Éà

#### Âü∫Êú¨Ê§úÁ¥¢„Éï„É≠„Éº„ÉÜ„Çπ„Éà
```typescript
// tests/e2e/unified-search.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Unified Search E2E', () => {
  test.beforeEach(async ({ page }) => {
    // „ÉÜ„Çπ„Éà„Éá„Éº„ÇøÊ∫ñÂÇô
    await page.goto('/test-setup')
    await page.click('[data-testid="setup-test-data"]')
    await page.waitForSelector('[data-testid="setup-complete"]')
  })

  test('should perform complete search flow', async ({ page }) => {
    // 1. Ê§úÁ¥¢„Éö„Éº„Ç∏„Å´ÁßªÂãï
    await page.goto('/search')
    await expect(page).toHaveTitle(/Ê§úÁ¥¢ - ChatFlow/)

    // 2. Ê§úÁ¥¢ÂÖ•Âäõ
    const searchInput = page.locator('[data-testid="search-input"]')
    await searchInput.fill('React TypeScript')
    
    // 3. „É™„Ç¢„É´„Çø„Ç§„É†Ê§úÁ¥¢„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
    await page.waitForSelector('[data-testid="search-results"]', { timeout: 5000 })
    
    // 4. ÁµêÊûúË°®Á§∫Á¢∫Ë™ç
    const results = page.locator('[data-testid="result-item"]')
    await expect(results).toHaveCountGreaterThan(0)
    
    // 5. „Çª„ÉÉ„Ç∑„Éß„É≥ÁµêÊûú„Çí„ÇØ„É™„ÉÉ„ÇØ
    const firstSessionResult = page.locator('[data-testid="session-result"]').first()
    await firstSessionResult.click()
    
    // 6. „Çª„ÉÉ„Ç∑„Éß„É≥Ë©≥Á¥∞„Éö„Éº„Ç∏„Å´ÈÅ∑ÁßªÁ¢∫Ë™ç
    await expect(page).toHaveURL(/\/sessions\/.*/)
    await expect(page.locator('[data-testid="session-title"]')).toBeVisible()
  })

  test('should show search suggestions', async ({ page }) => {
    // 1. Ê§úÁ¥¢„Éö„Éº„Ç∏„Å´ÁßªÂãï
    await page.goto('/search')
    
    // 2. Ê§úÁ¥¢ÂÖ•Âäõ„Éï„Ç©„Éº„Ç´„Çπ
    const searchInput = page.locator('[data-testid="search-input"]')
    await searchInput.focus()
    
    // 3. ÂÄôË£úË°®Á§∫Á¢∫Ë™ç
    await expect(page.locator('[data-testid="search-suggestions"]')).toBeVisible()
    
    // 4. ÈÉ®ÂàÜÁöÑ„Å™ÂÖ•Âäõ„Åß„ÅÆÂÄôË£úÊõ¥Êñ∞
    await searchInput.type('Rea')
    await page.waitForTimeout(500) // „Éá„Éê„Ç¶„É≥„ÇπÂæÖÊ©ü
    
    const suggestions = page.locator('[data-testid="suggestion-item"]')
    await expect(suggestions).toHaveCountGreaterThan(0)
    
    // 5. ÂÄôË£ú„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Ê§úÁ¥¢ÂÆüË°å
    await suggestions.first().click()
    await expect(page.locator('[data-testid="search-results"]')).toBeVisible()
  })

  test('should filter search results', async ({ page }) => {
    // 1. Ê§úÁ¥¢ÂÆüË°å
    await page.goto('/search')
    await page.fill('[data-testid="search-input"]', 'React')
    await page.waitForSelector('[data-testid="search-results"]')
    
    // 2. ÂàùÊúüÁµêÊûú„ÅÆÁ¢∫Ë™ç
    const allResultsCount = await page.locator('[data-testid="result-item"]').count()
    expect(allResultsCount).toBeGreaterThan(0)
    
    // 3. „Çª„ÉÉ„Ç∑„Éß„É≥„Éï„Ç£„É´„Çø„Éº„ÅÆ„ÅøÊúâÂäπÂåñ
    await page.click('[data-testid="filter-sessions"]')
    await page.click('[data-testid="filter-messages"]') // ÁÑ°ÂäπÂåñ
    
    // 4. „Éï„Ç£„É´„Çø„ÉºÈÅ©Áî®Âæå„ÅÆÁµêÊûúÁ¢∫Ë™ç
    await page.waitForTimeout(1000) // „Éï„Ç£„É´„Çø„ÉºÈÅ©Áî®ÂæÖÊ©ü
    const sessionResults = page.locator('[data-testid="session-result"]')
    const messageResults = page.locator('[data-testid="message-result"]')
    
    await expect(sessionResults).toHaveCountGreaterThan(0)
    await expect(messageResults).toHaveCount(0)
  })

  test('should handle empty search results', async ({ page }) => {
    // 1. Â≠òÂú®„Åó„Å™„ÅÑ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅßÊ§úÁ¥¢
    await page.goto('/search')
    await page.fill('[data-testid="search-input"]', 'xyznonexistentkeyword123')
    await page.waitForTimeout(1000)
    
    // 2. Á©∫Áä∂ÊÖã„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÁ¢∫Ë™ç
    await expect(page.locator('[data-testid="empty-state"]')).toBeVisible()
    await expect(page.locator('[data-testid="empty-state-message"]'))
      .toContainText('Ê§úÁ¥¢ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì')
    
    // 3. Ê§úÁ¥¢„ÇØ„É™„Ç¢ÊèêÊ°à„ÅÆÁ¢∫Ë™ç
    await expect(page.locator('[data-testid="clear-search-button"]')).toBeVisible()
  })

  test('should navigate between result types', async ({ page }) => {
    // 1. Ê§úÁ¥¢ÂÆüË°å
    await page.goto('/search')
    await page.fill('[data-testid="search-input"]', 'React')
    await page.waitForSelector('[data-testid="search-results"]')
    
    // 2. ÁµêÊûú„Çø„Éñ„ÅÆÁ¢∫Ë™ç
    const allTab = page.locator('[data-testid="tab-all"]')
    const sessionsTab = page.locator('[data-testid="tab-sessions"]')
    const messagesTab = page.locator('[data-testid="tab-messages"]')
    
    await expect(allTab).toBeVisible()
    await expect(sessionsTab).toBeVisible()
    await expect(messagesTab).toBeVisible()
    
    // 3. „Çª„ÉÉ„Ç∑„Éß„É≥„Çø„Éñ„ÇØ„É™„ÉÉ„ÇØ
    await sessionsTab.click()
    await expect(page.locator('[data-testid="session-result"]')).toBeVisible()
    await expect(page.locator('[data-testid="message-result"]')).not.toBeVisible()
    
    // 4. „É°„ÉÉ„Çª„Éº„Ç∏„Çø„Éñ„ÇØ„É™„ÉÉ„ÇØ
    await messagesTab.click()
    await expect(page.locator('[data-testid="message-result"]')).toBeVisible()
    await expect(page.locator('[data-testid="session-result"]')).not.toBeVisible()
  })
})
```

### „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà
```typescript
// tests/e2e/accessibility.spec.ts
import { test, expect } from '@playwright/test'
import AxeBuilder from '@axe-core/playwright'

test.describe('Search Accessibility', () => {
  test('should be accessible', async ({ page }) => {
    // Ê§úÁ¥¢„Éö„Éº„Ç∏„Å´ÁßªÂãï
    await page.goto('/search')
    
    // axe-core„Åß„Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØ
    const accessibilityScanResults = await new AxeBuilder({ page }).analyze()
    
    expect(accessibilityScanResults.violations).toEqual([])
  })

  test('should support keyboard navigation', async ({ page }) => {
    await page.goto('/search')
    
    // Tab „Ç≠„Éº„Åß„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥
    await page.keyboard.press('Tab')
    await expect(page.locator('[data-testid="search-input"]')).toBeFocused()
    
    // Ê§úÁ¥¢ÂÄôË£ú„Åß„ÅÆ„Ç≠„Éº„Éú„Éº„Éâ„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥
    await page.fill('[data-testid="search-input"]', 'Re')
    await page.waitForSelector('[data-testid="search-suggestions"]')
    
    await page.keyboard.press('ArrowDown')
    await expect(page.locator('[data-testid="suggestion-item"]:first-child')).toBeFocused()
    
    await page.keyboard.press('Enter')
    await expect(page.locator('[data-testid="search-results"]')).toBeVisible()
  })
})
```

---

## ‚ö° „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà

### Ê§úÁ¥¢ÈÄüÂ∫¶„ÉÜ„Çπ„Éà
```typescript
// tests/performance/search-performance.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Search Performance', () => {
  test('should meet search speed requirements', async ({ page }) => {
    await page.goto('/search')
    
    // Ê§úÁ¥¢ÂÆüË°åÊôÇÈñìÊ∏¨ÂÆö
    const startTime = Date.now()
    
    await page.fill('[data-testid="search-input"]', 'React TypeScript Component')
    await page.waitForSelector('[data-testid="search-results"]')
    
    const endTime = Date.now()
    const searchTime = endTime - startTime
    
    // 300ms‰ª•‰∏ã„ÅÆË¶Å‰ª∂Á¢∫Ë™ç
    expect(searchTime).toBeLessThan(300)
  })

  test('should handle large result sets efficiently', async ({ page }) => {
    await page.goto('/search')
    
    // Â§ßÈáèÁµêÊûú„ÇíËøî„Åô„ÇØ„Ç®„É™
    await page.fill('[data-testid="search-input"]', 'a') // ‰∏ÄËà¨ÁöÑ„Å™ÊñáÂ≠ó
    
    const startTime = Date.now()
    await page.waitForSelector('[data-testid="search-results"]')
    const endTime = Date.now()
    
    // „É¨„É≥„ÉÄ„É™„É≥„Ç∞ÊôÇÈñì„ÅÆÁ¢∫Ë™ç
    expect(endTime - startTime).toBeLessThan(500)
    
    // ‰ªÆÊÉ≥„Çπ„ÇØ„É≠„Éº„É´„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
    const resultItems = page.locator('[data-testid="result-item"]')
    const visibleCount = await resultItems.count()
    
    // ÂÖ®ÁµêÊûú„Çí„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Åõ„Åö„ÄÅË°®Á§∫È†òÂüü„ÅÆ„Åø„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
    expect(visibleCount).toBeLessThanOrEqual(20)
  })

  test('should cache search results effectively', async ({ page }) => {
    await page.goto('/search')
    
    // ÂàùÂõûÊ§úÁ¥¢
    const firstSearchStart = Date.now()
    await page.fill('[data-testid="search-input"]', 'React')
    await page.waitForSelector('[data-testid="search-results"]')
    const firstSearchTime = Date.now() - firstSearchStart
    
    // Ê§úÁ¥¢„ÇØ„É™„Ç¢
    await page.fill('[data-testid="search-input"]', '')
    await page.waitForTimeout(500)
    
    // Âêå„Åò„ÇØ„Ç®„É™„ÅßÂÜçÊ§úÁ¥¢Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•‰ΩøÁî®Ôºâ
    const secondSearchStart = Date.now()
    await page.fill('[data-testid="search-input"]', 'React')
    await page.waitForSelector('[data-testid="search-results"]')
    const secondSearchTime = Date.now() - secondSearchStart
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´„Çà„Çä2ÂõûÁõÆ„ÅÆÊñπ„ÅåÈ´òÈÄü„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
    expect(secondSearchTime).toBeLessThan(firstSearchTime * 0.5)
  })
})
```

### API „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
```typescript
// tests/performance/api-performance.test.ts
import { performance } from 'perf_hooks'
import { apiClient } from '../src/api/client'

describe('API Performance Tests', () => {
  test('should respond within SLA for unified search', async () => {
    const queries = [
      'React',
      'TypeScript error',
      'JavaScript function',
      'Python tutorial',
      'data analysis'
    ]
    
    for (const query of queries) {
      const startTime = performance.now()
      
      const response = await apiClient.searchUnified(query, {
        includeSessionTitles: true,
        includeMessageContent: true,
        includeTags: true
      })
      
      const endTime = performance.now()
      const responseTime = endTime - startTime
      
      // 200ms‰ª•‰∏ã„ÅÆSLAÁ¢∫Ë™ç
      expect(responseTime).toBeLessThan(200)
      expect(response.data.performance.searchTime).toBeLessThan(150)
    }
  })

  test('should handle concurrent searches efficiently', async () => {
    const concurrentQueries = Array(10).fill('React').map((q, i) => `${q} ${i}`)
    
    const startTime = performance.now()
    
    const promises = concurrentQueries.map(query => 
      apiClient.searchUnified(query, {})
    )
    
    const results = await Promise.all(promises)
    
    const endTime = performance.now()
    const totalTime = endTime - startTime
    
    // ‰∏¶Ë°åÂá¶ÁêÜ„Å´„Çà„ÇäÂäπÁéáÁöÑ„Å´Âá¶ÁêÜ„Åï„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
    expect(totalTime).toBeLessThan(1000) // 1Áßí‰ª•ÂÜÖ
    expect(results).toHaveLength(10)
    results.forEach(result => {
      expect(result.data.performance.searchTime).toBeLessThan(200)
    })
  })
})
```

---

## üìä „ÉÜ„Çπ„ÉàÂÆüË°å„ÉªÁõ£Ë¶ñ

### „ÉÜ„Çπ„ÉàÂÆüË°å„Ç≥„Éû„É≥„Éâ
```bash
# ÂÖ®„ÉÜ„Çπ„ÉàÂÆüË°å
npm run test

# „É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„Éà„ÅÆ„Åø
npm run test:unit

# Áµ±Âêà„ÉÜ„Çπ„Éà„ÅÆ„Åø
npm run test:integration

# E2E„ÉÜ„Çπ„Éà„ÅÆ„Åø
npm run test:e2e

# „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà„ÅÆ„Åø
npm run test:performance

# „Ç´„Éê„É¨„ÉÉ„Ç∏‰ªò„Åç„ÉÜ„Çπ„Éà
npm run test:coverage

# „Ç¶„Ç©„ÉÉ„ÉÅ„É¢„Éº„Éâ
npm run test:watch
```

### „ÉÜ„Çπ„ÉàË®≠ÂÆö„Éï„Ç°„Ç§„É´
```json
// jest.config.js
{
  "projects": [
    {
      "displayName": "unit",
      "testMatch": ["<rootDir>/src/**/*.test.ts", "<rootDir>/web/src/**/*.test.tsx"],
      "setupFilesAfterEnv": ["<rootDir>/src/test-utils/setup.ts"]
    },
    {
      "displayName": "integration", 
      "testMatch": ["<rootDir>/src/**/*.integration.test.ts"],
      "setupFilesAfterEnv": ["<rootDir>/src/test-utils/integration-setup.ts"]
    }
  ],
  "coverageThreshold": {
    "global": {
      "branches": 85,
      "functions": 85,
      "lines": 85,
      "statements": 85
    }
  }
}
```

### CI/CDÁµ±Âêà
```yaml
# .github/workflows/test.yml
name: Test Suite
on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:unit
      - run: npm run test:coverage
      
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run test:integration
      
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run build
      - run: npx playwright install
      - run: npm run test:e2e
      
  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run test:performance
```

### Á∂ôÁ∂öÁöÑÁõ£Ë¶ñ
```typescript
// src/monitoring/search-metrics.ts
export class SearchMetrics {
  private static instance: SearchMetrics
  
  async recordSearchPerformance(query: string, duration: number, resultCount: number) {
    // „É°„Éà„É™„ÇØ„ÇπË®òÈå≤
    await this.sendMetric({
      metric: 'search.duration',
      value: duration,
      tags: { query_length: query.length.toString() }
    })
    
    await this.sendMetric({
      metric: 'search.result_count',
      value: resultCount,
      tags: { query }
    })
    
    // SLAÈÅïÂèç„ÅÆÊ§úÂá∫
    if (duration > 300) {
      console.warn(`Search SLA violation: ${duration}ms for query "${query}"`)
    }
  }
  
  async generateDailyReport() {
    const metrics = await this.getMetrics({
      timeRange: '24h',
      metrics: ['search.duration', 'search.result_count', 'search.error_rate']
    })
    
    return {
      averageSearchTime: metrics.search.duration.avg,
      p95SearchTime: metrics.search.duration.p95,
      totalSearches: metrics.search.duration.count,
      errorRate: metrics.search.error_rate.avg,
      slaCompliance: (metrics.search.duration.count - metrics.search.sla_violations) / metrics.search.duration.count
    }
  }
}
```

---

## üìà ÂìÅË≥™„Ç≤„Éº„Éà

### ÂìÅË≥™Âü∫Ê∫ñ
```typescript
interface QualityGates {
  unitTests: {
    coverage: "85%‰ª•‰∏ä"
    passRate: "100%"
  }
  integrationTests: {
    apiEndpoints: "100%ÈÄöÈÅé"
    databaseOperations: "100%ÈÄöÈÅé"
  }
  e2eTests: {
    criticalUserFlows: "100%ÈÄöÈÅé"
    accessibilityViolations: "0‰ª∂"
  }
  performance: {
    searchResponseTime: "< 200ms"
    uiResponseTime: "< 300ms"
    errorRate: "< 1%"
  }
}
```

### „É™„É™„Éº„ÇπÊâøË™çÂü∫Ê∫ñ
```bash
# „É™„É™„Éº„ÇπÂâç„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà
‚úÖ ÂÖ®„É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„ÉàÈÄöÈÅé
‚úÖ ÂÖ®Áµ±Âêà„ÉÜ„Çπ„ÉàÈÄöÈÅé  
‚úÖ ÂÖ®E2E„ÉÜ„Çπ„ÉàÈÄöÈÅé
‚úÖ „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„ÉàÈÄöÈÅé
‚úÖ „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„ÉàÈÄöÈÅé
‚úÖ „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Çπ„Ç≠„É£„É≥ÈÄöÈÅé
‚úÖ „Ç≥„Éº„Éâ„Ç´„Éê„É¨„ÉÉ„Ç∏85%‰ª•‰∏ä
‚úÖ ÊâãÂãïQA„ÉÜ„Çπ„ÉàÂÆå‰∫Ü
```

---

**‰ΩúÊàêÊó•**: 2025Âπ¥6Êúà04Êó•  
**„ÉÜ„Çπ„ÉàÊúüÈñì**: ÂÆüË£ÖÂÆå‰∫ÜÂæå1ÈÄ±Èñì  
**ÂìÅË≥™Ë≤¨‰ªªËÄÖ**: ÈñãÁô∫„ÉÅ„Éº„É† 